{"files":{"pxt.json":"{\n    \"name\": \"neopixel\",\n    \"version\": \"0.6.13\",\n    \"description\": \"AdaFruit NeoPixel driver\",\n    \"license\": \"MIT\",\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"neopixel.ts\",\n        \"sendBuffer.asm\",\n        \"_locales/ja/neopixel-strings.json\",\n        \"_locales/zh/neopixel-strings.json\",\n        \"_locales/de/neopixel-strings.json\",\n        \"_locales/de/neopixel-jsdoc-strings.json\"\n    ],\n    \"testFiles\": [\n        \"neotest.ts\"\n    ],\n    \"public\": true,\n    \"preferredEditor\": \"tsprj\"\n}","_locales/zh/neopixel-strings.json":"{\n  \"NeoPixelMode.RGB|block\": \"RGB（GRB顺序）\",\n  \"NeoPixelMode.RGBW|block\": \"RGB+W\",\n  \"NeoPixelMode.RGB_RGB|block\": \"RGB（RGB顺序）\",\n  \"NeoPixelColors.Red|block\": \"红\",\n  \"NeoPixelColors.Orange|block\": \"橙\",\n  \"NeoPixelColors.Yellow|block\": \"黄\",\n  \"NeoPixelColors.Green|block\": \"緑\",\n  \"NeoPixelColors.Blue|block\": \"蓝\",\n  \"NeoPixelColors.Indigo|block\": \"靛蓝\",\n  \"NeoPixelColors.Violet|block\": \"紫罗兰\",\n  \"NeoPixelColors.Purple|block\": \"紫\",\n  \"NeoPixelColors.White|block\": \"白\",\n  \"NeoPixelColors.Black|block\": \"黑\",\n  \"neopixel.Strip.showColor|block\": \"%strip|显示颜色%rgb=neopixel_colors\",\n  \"neopixel.Strip.showRainbow|block\": \"%strip|显示彩虹特效 （色相）从%startHue|到%endHue\",\n  \"neopixel.Strip.showBarGraph|block\": \"%strip|显示柱状图 值%value|最大值%high\",\n  \"neopixel.Strip.setPixelColor|block\": \"%strip|设置颜色 像素%pixeloffset|为 %rgb=neopixel_colors\",\n  \"neopixel.Strip.setPixelWhiteLED|block\": \"%strip|设置白灯(RGB+W) 像素%pixeloffset|为 %white\",\n  \"neopixel.Strip.show|block\": \"%strip|刷新显示\",\n  \"neopixel.Strip.clear|block\": \"%strip|清除显示\",\n  \"neopixel.Strip.length|block\": \"%strip|LED的数目\",\n  \"neopixel.Strip.setBrightness|block\": \"%strip|设置亮度为 %brightness\",\n  \"neopixel.Strip.easeBrightness|block\": \"%strip|减小亮度\",\n  \"neopixel.Strip.range|block\": \"%strip| 从像素%start|开始 长度%length|颗LED\",\n  \"neopixel.Strip.shift|block\": \"%strip|移动像素 偏移量%offset\",\n  \"neopixel.Strip.rotate|block\": \"%strip|循环像素 偏移量%offset\",\n  \"neopixel.hsl|block\": \"色相 %h|饱和度 %s|亮度 %l\",\n  \"neopixel.Strip.power|block\": \"%strip| 电流(mA)\",\n  \"neopixel.Strip.setMatrixWidth|block\": \"%strip|设置矩阵宽度 %width|旋转 %rotation|链路 %chain\",\n  \"neopixel.Strip.setMatrixColor|block\": \"%strip|设置矩阵像素 x %x|y %y|为 %rgb=neopixel_colors\",\n  \"neopixel.create|block\": \"引脚%pin|初始化灯带|%numleds|颗LED（模式%mode|）\",\n  \"neopixel.rgb|block\": \"RGB（红%red|绿%green|蓝%blue|）\"\n}\n","sendBuffer.asm":"sendBufferAsm:\n\n    push {r4,r5,r6,r7,lr}\n    \n    mov r4, r0 ; save buff\n    mov r6, r1 ; save pin\n    \n    mov r0, r4\n    bl BufferMethods::length\n    mov r5, r0\n    \n    mov r0, r4\n    bl BufferMethods::getBytes\n    mov r4, r0\n    \n    ; setup pin as digital\n    mov r0, r6\n    movs r1, #0\n    bl pins::digitalWritePin\n    \n    ; load pin address\n    mov r0, r6\n    bl pins::getPinAddress\n\n    ldr r0, [r0, #8] ; get mbed DigitalOut from MicroBitPin\n    ldr r1, [r0, #4] ; r1-mask for this pin\n    ldr r2, [r0, #16] ; r2-clraddr\n    ldr r3, [r0, #12] ; r3-setaddr\n    \n    cpsid i ; disable irq\n    \n    b .start\n    \n.nextbit:               ;            C0\n    str r1, [r3, #0]    ; pin := hi  C2\n    tst r6, r0          ;            C3\n    bne .islate         ;            C4\n    str r1, [r2, #0]    ; pin := lo  C6\n.islate:\n    lsrs r6, r6, #1     ; r6 >>= 1   C7\n    bne .justbit        ;            C8\n    \n    ; not just a bit - need new byte\n    adds r4, #1         ; r4++       C9\n    subs r5, #1         ; r5--       C10\n    bcc .stop           ; if (r5<0) goto .stop  C11\n.start:\n    movs r6, #0x80      ; reset mask C12\n    nop                 ;            C13\n\n.common:               ;             C13\n    str r1, [r2, #0]   ; pin := lo   C15\n    ; always re-load byte - it just fits with the cycles better this way\n    ldrb r0, [r4, #0]  ; r0 := *r4   C17\n    b .nextbit         ;             C20\n\n.justbit: ; C10\n    ; no nops, branch taken is already 3 cycles\n    b .common ; C13\n\n.stop:    \n    str r1, [r2, #0]   ; pin := lo\n    cpsie i            ; enable irq\n\n    pop {r4,r5,r6,r7,pc}\n\n","_locales/ja/neopixel-strings.json":"{\n  \"NeoPixelMode.RGB|block\": \"RGB（GRB順）\",\n  \"NeoPixelMode.RGBW|block\": \"RGB+W\",\n  \"NeoPixelMode.RGB_RGB|block\": \"RGB（RGB順）\",\n  \"NeoPixelColors.Red|block\": \"赤\",\n  \"NeoPixelColors.Orange|block\": \"だいだい\",\n  \"NeoPixelColors.Yellow|block\": \"黄\",\n  \"NeoPixelColors.Green|block\": \"緑\",\n  \"NeoPixelColors.Blue|block\": \"青\",\n  \"NeoPixelColors.Indigo|block\": \"あい\",\n  \"NeoPixelColors.Violet|block\": \"すみれ\",\n  \"NeoPixelColors.Purple|block\": \"紫\",\n  \"NeoPixelColors.White|block\": \"白\",\n  \"neopixel.Strip.showColor|block\": \"%strip|を%rgb=neopixel_colors|色に点灯する\",\n  \"neopixel.Strip.showRainbow|block\": \"%strip|をレインボーパターン（色相%startHue|から%endHue|）に点灯する\",\n  \"neopixel.Strip.showBarGraph|block\": \"%strip|棒グラフで点灯する 値%value|最大値%high\",\n  \"neopixel.Strip.setPixelColor|block\": \"%strip|の%pixeloffset|番目のLEDを%rgb=neopixel_colors|色に設定する\",\n  \"neopixel.Strip.setPixelWhiteLED|block\": \"%strip|の%pixeloffset|番目のLEDの白色を%white|に設定する\",\n  \"neopixel.Strip.show|block\": \"%strip|を設定した色で点灯する\",\n  \"neopixel.Strip.clear|block\": \"%strip|の設定を削除する\",\n  \"neopixel.Strip.length|block\": \"%strip|のLEDの数\",\n  \"neopixel.Strip.setBrightness|block\": \"%strip|の明るさを%brightness|に設定する\",\n  \"neopixel.Strip.easeBrightness|block\": \"%strip|に設定されている色を明るさで調整する\",\n  \"neopixel.Strip.range|block\": \"%strip|の%start|番目から%length|個のNeoPixel\",\n  \"neopixel.Strip.shift|block\": \"%strip|に設定されている色をLED%offset|個分ずらす\",\n  \"neopixel.Strip.rotate|block\": \"%strip|に設定されている色をLED%offset|個分ずらす（ひとまわり）\",\n  \"neopixel.create|block\": \"端子%pin|に接続しているLED|%numleds|個のNeoPixel（モード%mode|）\",\n  \"neopixel.rgb|block\": \"RGB（赤%red|緑%green|青%blue|）\",\n  \"neopixel.colors|block\": \"%color\",\n  \"neopixel.HSL.rotateHue|block\": \"HSL%hsl|の色相を%offset|ずらす\",\n  \"neopixel.HSL.toRGB|block\": \"HSL%hsl|をRGBに変換\",\n  \"neopixel.hsl|block\": \"HSL（色相%hue|彩度%sat|輝度%lum|）\"\n}\n","README.md":"# NeoPixel driver\n\n[![Community Discord](https://img.shields.io/discord/448979533891371018.svg)](https://aka.ms/makecodecommunity)\n\nThis library provides a driver for various Neo Pixel LED strips, \nsee https://www.adafruit.com/category/168.\n\nNeoPixels consist of programmable RGB LEDs (WS2812B), every one of them controlled\nseparately.  \n\n## ~ hint\n\nSee [Microsoft/pxt-ws2812b](https://makecode.microbit.org/pkg/microsoft/pxt-ws2812b) for basic WS2812B led support. \n\n## ~\n\n## Basic usage\n\n```blocks\n// Create a NeoPixel driver - specify the pin, number of LEDs, and the type of \n// the NeoPixel srip, either standard RGB (with GRB or RGB format) or RGB+White.\nlet strip = neopixel.create(DigitalPin.P0, 24, NeoPixelMode.RGB);\n\n// set pixel colors\nstrip.setPixelColor(0, NeoPixelColors.White); // white\nstrip.setPixelColor(1, 0xff0000);     // red\nstrip.setPixelColor(2, 0x00ff00);     // green\nstrip.setPixelColor(3, NeoPixelColors.Blue);    // blue\n\n// send the data to the strip\nstrip.show()\n```\n\nUse ``||setBrightness||`` to lower the brightness (it's maxed out by default).\n\nUse ``||shift||`` or ``||rotate||`` to shift the lights around.\n\nUse ``||setPixelWhiteLED||`` to set brightness of the white pixel for RGB+W strips. \n\n## HSL color format\n\nUse `neopixel.hslToRgb()` to create colors using hue, saturation, and lightness.\n\n## Example: Using accelerometer to control colors\n\nThis little program will let the position of the microbit control the color of the first LED.\nThis first LED will then get shifted further away every 100ms.\n\n```blocks\nlet strip = neopixel.create(DigitalPin.P0, 24, NeoPixelMode.RGB_RGB)\nwhile (true) {\n    let x = input.acceleration(Dimension.X) / 2;\n    let y = input.acceleration(Dimension.Y) / 2;\n    let z = input.acceleration(Dimension.Z) / 2;\n    strip.shift(1);\n    strip.setPixelColor(0, neopixel.rgb(x, y, -z));\n    strip.show();\n    basic.pause(100);\n}\n```\n\n## Supported targets\n\n* for PXT/microbit\n* for PXT/calliope\n\n## License\n\nMIT\n\n## Code of Conduct\n\nThis project has adopted the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/). For more information see the [Code of Conduct FAQ](https://opensource.microsoft.com/codeofconduct/faq/) or contact [opencode@microsoft.com](mailto:opencode@microsoft.com) with any additional questions or comments.\n","neopixel.ts":"/**\n * Well known colors for a NeoPixel strip\n */\nenum NeoPixelColors {\n    //% block=red\n    Red = 0xFF0000,\n    //% block=orange\n    Orange = 0xFFA500,\n    //% block=yellow\n    Yellow = 0xFFFF00,\n    //% block=green\n    Green = 0x00FF00,\n    //% block=blue\n    Blue = 0x0000FF,\n    //% block=indigo\n    Indigo = 0x4b0082,\n    //% block=violet\n    Violet = 0x8a2be2,\n    //% block=purple\n    Purple = 0xFF00FF,\n    //% block=white\n    White = 0xFFFFFF,\n    //% block=black\n    Black = 0x000000\n}\n\n/**\n * Different modes for RGB or RGB+W NeoPixel strips\n */\nenum NeoPixelMode {\n    //% block=\"RGB (GRB format)\"\n    RGB = 0,\n    //% block=\"RGB+W\"\n    RGBW = 1,\n    //% block=\"RGB (RGB format)\"\n    RGB_RGB = 2\n}\n\n/**\n * Functions to operate NeoPixel strips.\n */\n//% weight=5 color=#2699BF icon=\"\\uf110\"\nnamespace neopixel {\n    //% shim=sendBufferAsm\n    function sendBuffer(buf: Buffer, pin: DigitalPin) {\n    }\n\n    /**\n     * A NeoPixel strip\n     */\n    export class Strip {\n        buf: Buffer;\n        pin: DigitalPin;\n        // TODO: encode as bytes instead of 32bit\n        brightness: number;\n        start: number; // start offset in LED strip\n        _length: number; // number of LEDs\n        _mode: NeoPixelMode;\n        _matrixWidth: number; // number of leds in a matrix - if any\n        _matrixChain: number; // the connection type of matrix chain\n        _matrixRotation: number; // the rotation type of matrix\n\n        /**\n         * Shows all LEDs to a given color (range 0-255 for r, g, b). \n         * @param rgb RGB color of the LED\n         */\n        //% blockId=\"neopixel_set_strip_color\" block=\"%strip|show color %rgb=neopixel_colors\" \n        //% weight=85 blockGap=8\n        //% parts=\"neopixel\"\n        showColor(rgb: number) {\n            rgb = rgb >> 0;\n            this.setAllRGB(rgb);\n            this.show();\n        }\n\n        /**\n         * Shows a rainbow pattern on all LEDs. \n         * @param startHue the start hue value for the rainbow, eg: 1\n         * @param endHue the end hue value for the rainbow, eg: 360\n         */\n        //% blockId=\"neopixel_set_strip_rainbow\" block=\"%strip|show rainbow from %startHue|to %endHue\" \n        //% weight=85 blockGap=8\n        //% parts=\"neopixel\"\n        showRainbow(startHue: number = 1, endHue: number = 360) {\n            if (this._length <= 0) return;\n\n            startHue = startHue >> 0;\n            endHue = endHue >> 0;\n            const saturation = 100;\n            const luminance = 50;\n            const steps = this._length;\n            const direction = HueInterpolationDirection.Clockwise;\n\n            //hue\n            const h1 = startHue;\n            const h2 = endHue;\n            const hDistCW = ((h2 + 360) - h1) % 360;\n            const hStepCW = Math.idiv((hDistCW * 100), steps);\n            const hDistCCW = ((h1 + 360) - h2) % 360;\n            const hStepCCW = Math.idiv(-(hDistCCW * 100), steps);\n            let hStep: number;\n            if (direction === HueInterpolationDirection.Clockwise) {\n                hStep = hStepCW;\n            } else if (direction === HueInterpolationDirection.CounterClockwise) {\n                hStep = hStepCCW;\n            } else {\n                hStep = hDistCW < hDistCCW ? hStepCW : hStepCCW;\n            }\n            const h1_100 = h1 * 100; //we multiply by 100 so we keep more accurate results while doing interpolation\n\n            //sat\n            const s1 = saturation;\n            const s2 = saturation;\n            const sDist = s2 - s1;\n            const sStep = Math.idiv(sDist, steps);\n            const s1_100 = s1 * 100;\n\n            //lum\n            const l1 = luminance;\n            const l2 = luminance;\n            const lDist = l2 - l1;\n            const lStep = Math.idiv(lDist, steps);\n            const l1_100 = l1 * 100\n\n            //interpolate\n            if (steps === 1) {\n                this.setPixelColor(0, hsl(h1 + hStep, s1 + sStep, l1 + lStep))\n            } else {\n                this.setPixelColor(0, hsl(startHue, saturation, luminance));\n                for (let i = 1; i < steps - 1; i++) {\n                    const h = Math.idiv((h1_100 + i * hStep), 100) + 360;\n                    const s = Math.idiv((s1_100 + i * sStep), 100);\n                    const l = Math.idiv((l1_100 + i * lStep), 100);\n                    this.setPixelColor(i, hsl(h, s, l));\n                }\n                this.setPixelColor(steps - 1, hsl(endHue, saturation, luminance));\n            }\n            this.show();\n        }\n\n        /**\n         * Displays a vertical bar graph based on the `value` and `high` value.\n         * If `high` is 0, the chart gets adjusted automatically.\n         * @param value current value to plot\n         * @param high maximum value, eg: 255\n         */\n        //% weight=84\n        //% blockId=neopixel_show_bar_graph block=\"%strip|show bar graph of %value|up to %high\" \n        //% icon=\"\\uf080\"\n        //% parts=\"neopixel\"\n        showBarGraph(value: number, high: number): void {\n            if (high <= 0) {\n                this.clear();\n                this.setPixelColor(0, NeoPixelColors.Yellow);\n                this.show();\n                return;\n            }\n\n            value = Math.abs(value);\n            const n = this._length;\n            const n1 = n - 1;\n            let v = Math.idiv((value * n), high);\n            if (v == 0) {\n                this.setPixelColor(0, 0x666600);\n                for (let i = 1; i < n; ++i)\n                    this.setPixelColor(i, 0);\n            } else {\n                for (let i = 0; i < n; ++i) {\n                    if (i <= v) {\n                        const b = Math.idiv(i * 255, n1);\n                        this.setPixelColor(i, neopixel.rgb(b, 0, 255 - b));\n                    }\n                    else this.setPixelColor(i, 0);\n                }\n            }\n            this.show();\n        }\n\n        /**\n         * Set LED to a given color (range 0-255 for r, g, b). \n         * You need to call ``show`` to make the changes visible.\n         * @param pixeloffset position of the NeoPixel in the strip\n         * @param rgb RGB color of the LED\n         */\n        //% blockId=\"neopixel_set_pixel_color\" block=\"%strip|set pixel color at %pixeloffset|to %rgb=neopixel_colors\" \n        //% blockGap=8\n        //% weight=80\n        //% parts=\"neopixel\" advanced=true\n        setPixelColor(pixeloffset: number, rgb: number): void {\n            this.setPixelRGB(pixeloffset >> 0, rgb >> 0);\n        }\n\n        /**\n         * Sets the number of pixels in a matrix shaped strip\n         * @param width number of pixels in a row\n\t * @param rotation type of matrix\n\t * @param chain type of matrix\n         */\n        //% blockId=neopixel_set_matrix_width block=\"%strip|set matrix width %width|rotation %rotation|chain %chain\"\n        //% blockGap=8\n        //% weight=5\n        //% parts=\"neopixel\" advanced=true\n        setMatrixWidth(width: number, rotation: number, chain: number) {\n            this._matrixWidth = Math.min(this._length, width >> 0);\n            this._matrixRotation = rotation >> 0;\n            this._matrixChain = chain >> 0;\n        }\n\n        /**\n         * Set LED to a given color (range 0-255 for r, g, b) in a matrix shaped strip \n         * You need to call ``show`` to make the changes visible.\n         * @param x horizontal position\n         * @param y horizontal position\n         * @param rgb RGB color of the LED\n         */\n        //% blockId=\"neopixel_set_matrix_color\" block=\"%strip|set matrix color at x %x|y %y|to %rgb=neopixel_colors\" \n        //% weight=4\n        //% parts=\"neopixel\" advanced=true\n        setMatrixColor(x: number, y: number, rgb: number) {\n            if (this._matrixWidth <= 0) return; // not a matrix, ignore\n            x = x >> 0;\n            y = y >> 0;\n            rgb = rgb >> 0;\n            const cols = Math.idiv(this._length, this._matrixWidth);\n\n            if (this._matrixRotation == 1) {\n                let t = y;\n                y = x;\n                x = t;\n            } else if (this._matrixRotation == 2) {\n                x = this._matrixWidth - x - 1;\n            }\n\n\n            // here be the physical mapping\n            if (this._matrixChain == 1 && y % 2 == 1) {\n                x = this._matrixWidth - x - 1;\n            }\n            if (x < 0 || x >= this._matrixWidth || y < 0 || y >= cols) return;\n\n            let i = x + y * this._matrixWidth;\n            this.setPixelColor(i, rgb);\n        }\n\n        /**\n         * For NeoPixels with RGB+W LEDs, set the white LED brightness. This only works for RGB+W NeoPixels.\n         * @param pixeloffset position of the LED in the strip\n         * @param white brightness of the white LED\n         */\n        //% blockId=\"neopixel_set_pixel_white\" block=\"%strip|set pixel white LED at %pixeloffset|to %white\" \n        //% blockGap=8\n        //% weight=80\n        //% parts=\"neopixel\" advanced=true\n        setPixelWhiteLED(pixeloffset: number, white: number): void {\n            if (this._mode === NeoPixelMode.RGBW) {\n                this.setPixelW(pixeloffset >> 0, white >> 0);\n            }\n        }\n\n\n        /**\n         * Send all the changes to the strip.\n         */\n        //% blockId=\"neopixel_show\" block=\"%strip|show\" blockGap=8\n        //% weight=79\n        //% parts=\"neopixel\"\n        show() {\n            sendBuffer(this.buf, this.pin);\n        }\n\n        /**\n         * Turn off all LEDs.\n         * You need to call ``show`` to make the changes visible.\n         */\n        //% blockId=\"neopixel_clear\" block=\"%strip|clear\"\n        //% weight=76\n        //% parts=\"neopixel\"\n        clear(): void {\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            this.buf.fill(0, this.start * stride, this._length * stride);\n        }\n\n        /**\n         * Gets the number of pixels declared on the strip\n         */\n        //% blockId=\"neopixel_length\" block=\"%strip|length\" blockGap=8\n        //% weight=60 advanced=true\n        length() {\n            return this._length;\n        }\n\n        /**\n         * Set the brightness of the strip. This flag only applies to future operation.\n         * @param brightness a measure of LED brightness in 0-255. eg: 255\n         */\n        //% blockId=\"neopixel_set_brightness\" block=\"%strip|set brightness %brightness\" blockGap=8\n        //% weight=59\n        //% parts=\"neopixel\" advanced=true\n        setBrightness(brightness: number): void {\n            this.brightness = brightness & 0xff;\n        }\n\n        /**\n         * Apply brightness to current colors using a quadratic easing function.\n         **/\n        //% blockId=\"neopixel_each_brightness\" block=\"%strip|ease brightness\" blockGap=8\n        //% weight=58\n        //% parts=\"neopixel\" advanced=true\n        easeBrightness(): void {\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            const br = this.brightness;\n            const buf = this.buf;\n            const end = this.start + this._length;\n            const mid = Math.idiv(this._length, 2);\n            for (let i = this.start; i < end; ++i) {\n                const k = i - this.start;\n                const ledoffset = i * stride;\n                const br = k > mid\n                    ? Math.idiv(255 * (this._length - 1 - k) * (this._length - 1 - k), (mid * mid))\n                    : Math.idiv(255 * k * k, (mid * mid));\n                serial.writeLine(k + \":\" + br);\n                const r = (buf[ledoffset + 0] * br) >> 8; buf[ledoffset + 0] = r;\n                const g = (buf[ledoffset + 1] * br) >> 8; buf[ledoffset + 1] = g;\n                const b = (buf[ledoffset + 2] * br) >> 8; buf[ledoffset + 2] = b;\n                if (stride == 4) {\n                    const w = (buf[ledoffset + 3] * br) >> 8; buf[ledoffset + 3] = w;\n                }\n            }\n        }\n\n        /** \n         * Create a range of LEDs.\n         * @param start offset in the LED strip to start the range\n         * @param length number of LEDs in the range. eg: 4\n         */\n        //% weight=89\n        //% blockId=\"neopixel_range\" block=\"%strip|range from %start|with %length|leds\"\n        //% parts=\"neopixel\"\n        //% blockSetVariable=range\n        range(start: number, length: number): Strip {\n            start = start >> 0;\n            length = length >> 0;\n            let strip = new Strip();\n            strip.buf = this.buf;\n            strip.pin = this.pin;\n            strip.brightness = this.brightness;\n            strip.start = this.start + Math.clamp(0, this._length - 1, start);\n            strip._length = Math.clamp(0, this._length - (strip.start - this.start), length);\n            strip._matrixWidth = 0;\n            strip._mode = this._mode;\n            return strip;\n        }\n\n        /**\n         * Shift LEDs forward and clear with zeros.\n         * You need to call ``show`` to make the changes visible.\n         * @param offset number of pixels to shift forward, eg: 1\n         */\n        //% blockId=\"neopixel_shift\" block=\"%strip|shift pixels by %offset\" blockGap=8\n        //% weight=40\n        //% parts=\"neopixel\"\n        shift(offset: number = 1): void {\n            offset = offset >> 0;\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            this.buf.shift(-offset * stride, this.start * stride, this._length * stride)\n        }\n\n        /**\n         * Rotate LEDs forward.\n         * You need to call ``show`` to make the changes visible.\n         * @param offset number of pixels to rotate forward, eg: 1\n         */\n        //% blockId=\"neopixel_rotate\" block=\"%strip|rotate pixels by %offset\" blockGap=8\n        //% weight=39\n        //% parts=\"neopixel\"\n        rotate(offset: number = 1): void {\n            offset = offset >> 0;\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            this.buf.rotate(-offset * stride, this.start * stride, this._length * stride)\n        }\n\n        /**\n         * Set the pin where the neopixel is connected, defaults to P0.\n         */\n        //% weight=10\n        //% parts=\"neopixel\" advanced=true\n        setPin(pin: DigitalPin): void {\n            this.pin = pin;\n            pins.digitalWritePin(this.pin, 0);\n            // don't yield to avoid races on initialization\n        }\n\n        /**\n         * Estimates the electrical current (mA) consumed by the current light configuration.\n         */\n        //% weight=9 blockId=neopixel_power block=\"%strip|power (mA)\"\n        //% advanced=true\n        power(): number {\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            const end = this.start + this._length;\n            let p = 0;\n            for (let i = this.start; i < end; ++i) {\n                const ledoffset = i * stride;\n                for (let j = 0; j < stride; ++j) {\n                    p += this.buf[i + j];\n                }\n            }\n            return Math.idiv(this.length(), 2) /* 0.5mA per neopixel */\n                + Math.idiv(p * 433, 10000); /* rought approximation */\n        }\n\n        private setBufferRGB(offset: number, red: number, green: number, blue: number): void {\n            if (this._mode === NeoPixelMode.RGB_RGB) {\n                this.buf[offset + 0] = red;\n                this.buf[offset + 1] = green;\n            } else {\n                this.buf[offset + 0] = green;\n                this.buf[offset + 1] = red;\n            }\n            this.buf[offset + 2] = blue;\n        }\n\n        private setAllRGB(rgb: number) {\n            let red = unpackR(rgb);\n            let green = unpackG(rgb);\n            let blue = unpackB(rgb);\n\n            const br = this.brightness;\n            if (br < 255) {\n                red = (red * br) >> 8;\n                green = (green * br) >> 8;\n                blue = (blue * br) >> 8;\n            }\n            const end = this.start + this._length;\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            for (let i = this.start; i < end; ++i) {\n                this.setBufferRGB(i * stride, red, green, blue)\n            }\n        }\n        private setAllW(white: number) {\n            if (this._mode !== NeoPixelMode.RGBW)\n                return;\n\n            let br = this.brightness;\n            if (br < 255) {\n                white = (white * br) >> 8;\n            }\n            let buf = this.buf;\n            let end = this.start + this._length;\n            for (let i = this.start; i < end; ++i) {\n                let ledoffset = i * 4;\n                buf[ledoffset + 3] = white;\n            }\n        }\n        private setPixelRGB(pixeloffset: number, rgb: number): void {\n            if (pixeloffset < 0\n                || pixeloffset >= this._length)\n                return;\n\n            let stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            pixeloffset = (pixeloffset + this.start) * stride;\n\n            let red = unpackR(rgb);\n            let green = unpackG(rgb);\n            let blue = unpackB(rgb);\n\n            let br = this.brightness;\n            if (br < 255) {\n                red = (red * br) >> 8;\n                green = (green * br) >> 8;\n                blue = (blue * br) >> 8;\n            }\n            this.setBufferRGB(pixeloffset, red, green, blue)\n        }\n        private setPixelW(pixeloffset: number, white: number): void {\n            if (this._mode !== NeoPixelMode.RGBW)\n                return;\n\n            if (pixeloffset < 0\n                || pixeloffset >= this._length)\n                return;\n\n            pixeloffset = (pixeloffset + this.start) * 4;\n\n            let br = this.brightness;\n            if (br < 255) {\n                white = (white * br) >> 8;\n            }\n            let buf = this.buf;\n            buf[pixeloffset + 3] = white;\n        }\n    }\n\n    /**\n     * Create a new NeoPixel driver for `numleds` LEDs.\n     * @param pin the pin where the neopixel is connected.\n     * @param numleds number of leds in the strip, eg: 24,30,60,64\n     */\n    //% blockId=\"neopixel_create\" block=\"NeoPixel at pin %pin|with %numleds|leds as %mode\"\n    //% weight=90 blockGap=8\n    //% parts=\"neopixel\"\n    //% trackArgs=0,2\n    //% blockSetVariable=strip\n    export function create(pin: DigitalPin, numleds: number, mode: NeoPixelMode): Strip {\n        let strip = new Strip();\n        let stride = mode === NeoPixelMode.RGBW ? 4 : 3;\n        strip.buf = pins.createBuffer(numleds * stride);\n        strip.start = 0;\n        strip._length = numleds;\n        strip._mode = mode;\n        strip._matrixWidth = 0;\n        strip.setBrightness(255)\n        strip.setPin(pin)\n        return strip;\n    }\n\n    /**\n     * Converts red, green, blue channels into a RGB color\n     * @param red value of the red channel between 0 and 255. eg: 255\n     * @param green value of the green channel between 0 and 255. eg: 255\n     * @param blue value of the blue channel between 0 and 255. eg: 255\n     */\n    //% weight=1\n    //% blockId=\"neopixel_rgb\" block=\"red %red|green %green|blue %blue\"\n    //% advanced=true\n    export function rgb(red: number, green: number, blue: number): number {\n        return packRGB(red, green, blue);\n    }\n\n    /**\n     * Gets the RGB value of a known color\n    */\n    //% weight=2 blockGap=8\n    //% blockId=\"neopixel_colors\" block=\"%color\"\n    //% advanced=true\n    export function colors(color: NeoPixelColors): number {\n        return color;\n    }\n\n    function packRGB(a: number, b: number, c: number): number {\n        return ((a & 0xFF) << 16) | ((b & 0xFF) << 8) | (c & 0xFF);\n    }\n    function unpackR(rgb: number): number {\n        let r = (rgb >> 16) & 0xFF;\n        return r;\n    }\n    function unpackG(rgb: number): number {\n        let g = (rgb >> 8) & 0xFF;\n        return g;\n    }\n    function unpackB(rgb: number): number {\n        let b = (rgb) & 0xFF;\n        return b;\n    }\n\n    /**\n     * Converts a hue saturation luminosity value into a RGB color\n     * @param h hue from 0 to 360\n     * @param s saturation from 0 to 99\n     * @param l luminosity from 0 to 99\n     */\n    //% blockId=neopixelHSL block=\"hue %h|saturation %s|luminosity %l\"\n    export function hsl(h: number, s: number, l: number): number {\n        h = Math.round(h);\n        s = Math.round(s);\n        l = Math.round(l);\n\n        h = h % 360;\n        s = Math.clamp(0, 99, s);\n        l = Math.clamp(0, 99, l);\n        let c = Math.idiv((((100 - Math.abs(2 * l - 100)) * s) << 8), 10000); //chroma, [0,255]\n        let h1 = Math.idiv(h, 60);//[0,6]\n        let h2 = Math.idiv((h - h1 * 60) * 256, 60);//[0,255]\n        let temp = Math.abs((((h1 % 2) << 8) + h2) - 256);\n        let x = (c * (256 - (temp))) >> 8;//[0,255], second largest component of this color\n        let r$: number;\n        let g$: number;\n        let b$: number;\n        if (h1 == 0) {\n            r$ = c; g$ = x; b$ = 0;\n        } else if (h1 == 1) {\n            r$ = x; g$ = c; b$ = 0;\n        } else if (h1 == 2) {\n            r$ = 0; g$ = c; b$ = x;\n        } else if (h1 == 3) {\n            r$ = 0; g$ = x; b$ = c;\n        } else if (h1 == 4) {\n            r$ = x; g$ = 0; b$ = c;\n        } else if (h1 == 5) {\n            r$ = c; g$ = 0; b$ = x;\n        }\n        let m = Math.idiv((Math.idiv((l * 2 << 8), 100) - c), 2);\n        let r = r$ + m;\n        let g = g$ + m;\n        let b = b$ + m;\n        return packRGB(r, g, b);\n    }\n\n    export enum HueInterpolationDirection {\n        Clockwise,\n        CounterClockwise,\n        Shortest\n    }\n}\n","neotest.ts":"{\n    let strip = neopixel.create(DigitalPin.P0, 24, NeoPixelMode.RGB);\n\n    strip.showRainbow();\n    for (let i = 0; i <= strip.length(); i++) { \n        strip.rotate();\n        strip.show();\n        basic.pause(100)\n    }\n    \n    strip.showColor(NeoPixelColors.Red)\n    basic.pause(2000)\n    strip.showColor(NeoPixelColors.Green)\n    basic.pause(1000)\n    for (let i = 0; i <= strip.length(); i++) {\n        strip.setPixelColor(i, neopixel.colors(NeoPixelColors.Blue))\n        strip.show()\n        basic.pause(100)\n    }\n    for (let i = 0; i <= strip.length(); i++) {\n        strip.setPixelColor(i, neopixel.colors(NeoPixelColors.Green))\n        strip.show()\n        basic.pause(100)\n    }\n    let sub = strip.range(10, 20)\n    sub.showColor(NeoPixelColors.Yellow);\n    basic.pause(200);\n\n    sub.showBarGraph(5, 10);\n    basic.pause(200);\n\n    let br = 100;\n    strip.setBrightness(100);\n    input.onButtonPressed(Button.B, () => {\n        br = br + 20;\n        if (br > 255) {\n            br = 5;\n        }\n        strip.setBrightness(br);\n    });\n\n    let rotationMode = false;\n    input.onButtonPressed(Button.A, () => {\n        rotationMode = !rotationMode;\n        if (rotationMode) {\n            basic.showLeds(`\n            . # # # .\n            # . . . #\n            # . . . #\n            # . . . #\n            . # # # .\n            `);\n        } else {\n            basic.showLeds(`\n            . . # . .\n            . . . # .\n            # # # # #\n            . . . # .\n            . . # . .\n            `);\n\n        }\n    });\n\n    while (true) {\n        let x = input.acceleration(Dimension.X) >> 1\n        let y = input.acceleration(Dimension.Y) >> 1\n        let z = input.acceleration(Dimension.Z) >> 1\n        if (rotationMode) {\n            strip.rotate();\n        } else {\n            strip.setPixelColor(0, neopixel.rgb(x, y, -z));\n            strip.shift(1);\n        }\n        strip.show();\n        basic.pause(100);\n    }\n}\n","_locales/de/neopixel-jsdoc-strings.json":"{\n  \"neopixel.create\": \"Erzeuge einen neuen Treiber für die gegebene Anzahl NeoPixels, die am angegebenen Port angeschlossen sind. Der Modus bestimmt die genaue Bauart der NeoPixel.\",\n  \"neopixel.Strip.showColor\": \"Setze alle Pixel auf die angegebene Farbe und rufe ``anzeigen`` auf.\",\n  \"neopixel.Strip.setBrigthness\": \"Setze die Helligkeit der NeoPixel (0-255). Die Änderung betrifft nur zukünftige Operationen.\",\n  \"neopixel.HSL.rotateHue\": \"Rotiert den Farbwert einer HSL-Farbe\",\n  \"neopixel.HSL.toRGB\": \"Konvertiert eine HSL-Farbe in eine RGB-Farbe.\",\n  \"neopixel.Strip.clear\": \"Schalte alle NeoPixel aus. Damit die Änderung sichtbar wird, muss anschließend ``anzeigen`` aufgerufen werden.\",\n  \"neopixel.Strip.easeBrightness\": \"Aktuelle Farben der NeoPixel je nach Pixelnr. abdunkeln.\",\n  \"neopixel.Strip.length\": \"Die Anzahl der NeoPixel, die der Treiber verwaltet.\",\n  \"neopixel.Strip.range\": \"Erstellt einen neuen Treiber für ein Intervall der vom angegebenen Treiber verwalteten NeoPixel.\",\n  \"neopixel.Strip.rotate\": \"Rotiert die Farben der NeoPixel. Damit die Änderung sichtbar wird, muss anschließend ``anzeigen`` aufgerufen werden.\",\n  \"neopixel.Strip.setPixelColor\": \"Setzt den NeoPixel mit der angegebenen Nr. auf die angegebene Farbe. Damit die Änderung sichtbar wird, muss anschließend ``anzeigen`` aufgerufen werden.\",\n  \"neopixel.Strip.setPixelWhiteLED\": \"Setzt die Helligkeit der weißen LED des NeoPixels mit der angegebenen Nr. Dies funktioniert nur für RGB+W Neopixel. Damit die Änderung sichtbar wird, muss anschließend ``anzeigen`` aufgerufen werden.\",\n  \"neopixel.Strip.shift\": \"Verschiebt die Farben der NeoPixel. Damit die Änderung sichtbar wird, muss anschließend ``anzeigen`` aufgerufen werden.\",\n  \"neopixel.Strip.showBarGraph\": \"Zeigt den angegebenen Wert in Bezug auf das gegebene Maximum als Balkendiagramm auf allen Neopixeln an.\",\n  \"neopixel.Strip.showRainbow\": \"Zeigt ein Regenbogenmuster auf allen NeoPixeln an.\",\n  \"neopixel.Strip.show\": \"Sendet alle Änderungen an die NeoPixel.\",\n  \"neopixel.hsl\": \"Erstellt eine HSL-Farbe\",\n  \"neopixel.rgb\": \"Erstellt eine RGB-Farbe\",\n  \"neopixel.colors\": \"bekannte RGB-Farben\"\n}\n","_locales/de/neopixel-strings.json":"{\n  \"NeoPixelColors.Black|block\": \"schwarz\",\n  \"NeoPixelColors.Blue|block\": \"blau\",\n  \"NeoPixelColors.Green|block\": \"grün\",\n  \"NeoPixelColors.Indigo|block\": \"indigo\",\n  \"NeoPixelColors.Orange|block\": \"orange\",\n  \"NeoPixelColors.Purple|block\": \"magenta\",\n  \"NeoPixelColors.Red|block\": \"rot\",\n  \"NeoPixelColors.Violet|block\": \"blauviolett\",\n  \"NeoPixelColors.White|block\": \"weiß\",\n  \"NeoPixelColors.Yellow|block\": \"gelb\",\n  \"NeoPixelMode.RGBW|block\": \"RGB+W\",\n  \"NeoPixelMode.RGB_RGB|block\": \"RGB (RGB Format)\",\n  \"NeoPixelMode.RGB|block\": \"RGB (GRB Format)\",\n  \"neopixel.HSL.rotateHue|block\": \"HSL-Farbe: rotiere Farbwert von %hsl| um %offset\",\n  \"neopixel.HSL.toRGB|block\": \"%hsl|nach RGB\",\n  \"neopixel.Strip.clear|block\": \"%strip|ausschalten\",\n  \"neopixel.Strip.easeBrightness|block\": \"%strip|abdunkeln\",\n  \"neopixel.Strip.length|block\": \"%strip|Länge\",\n  \"neopixel.Strip.range|block\": \"%strip|Intervall von %start|mit %length| NeoPixeln\",\n  \"neopixel.Strip.rotate|block\": \"%strip|rotiere NeoPixel um %offset\",\n  \"neopixel.Strip.setBrightness|block\": \"%strip|setze Helligkeit %brightness\",\n  \"neopixel.Strip.setPixelColor|block\": \"%strip|setze Farbe von NeoPixel %pixeloffset|auf %rgb=neopixel_colors\",\n  \"neopixel.Strip.setPixelWhiteLED|block\": \"%strip|setze weiße LED von NeoPixel %pixeloffset|auf %white\",\n  \"neopixel.Strip.shift|block\": \"%strip|verschiebe NeoPixel um %offset\",\n  \"neopixel.Strip.showBarGraph|block\": \"%strip|zeige Balkendiagramm von Wert %value |mit Maximum %high\",\n  \"neopixel.Strip.showColor|block\": \"%strip|zeige Farbe %rgb=neopixel_colors\",\n  \"neopixel.Strip.showRainbow|block\": \"%strip|zeige Regenbogen von Farbton %startHue|bis %endHue\",\n  \"neopixel.Strip.show|block\": \"%strip|anzeigen\",\n  \"neopixel.colors|block\": \"%color\",\n  \"neopixel.create|block\": \"NeoPixels an Pin %pin|mit %numleds|Pixeln und Modus %mode\",\n  \"neopixel.hsl|block\": \"HSL-Farbe: Farbwert %hue|Sättigung %sat|Helligkeit %lum\",\n  \"neopixel.power|block\": \"%strip|Stromverbrauch (mA)\",\n  \"neopixel.rgb|block\": \"rot %red|grün %green|blau %blue\",\n  \"neopixel.setMatrixColor|block\": \"%string|setze Matrix Farbe an Position x %x|y %y|auf %rgb=neopixel_colors\",\n  \"neopixel.setMatrixWidth|block\": \"%strip|setze Matrix Breite %width\",\n  \"{id:category}Neopixel\": \"NeoPixel\"\n}\n"}}